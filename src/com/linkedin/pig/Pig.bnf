{
  parserClass="com.linkedin.pig.parser.PigParser"
  stubParserClass="com.linkedin.pig.parser.GeneratedParserUtilBase"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Pig"
  psiImplClassSuffix="Impl"
  psiPackage="com.linkedin.pig.psi"
  psiImplPackage="com.linkedin.pig.psi.impl"

  elementTypeHolderClass="com.linkedin.pig.psi.PigTypes"
  elementTypeClass="com.linkedin.pig.psi.PigElementType"
  tokenTypeClass="com.linkedin.pig.psi.PigTokenType"

  //extends(".*_statement|comment")=statement
}

pigFile ::= statement*
//private recover_ ::= !(WHITE_SPACE)

statement ::= (import_statement | general_statement) //| foreach_statement | split_statement | inline_statement |


import_statement ::= IMPORT_KEYWORD string SEMICOLON


general_statement ::= (alias EQUAL)? (op_clause parallel_clause? | LPARENTH op_clause parallel_clause? RPARENTH) SEMICOLON //{recoverUntil="recover_"}

alias ::= id
id ::= IDENTIFIER

op_clause ::= load_clause
            /*
            | define_clause
            | group_clause
            | store_clause
            | filter_clause
            | distinct_clause
            | limit_clause
            | sample_clause
            | order_clause
            | cross_clause
            | join_clause
            | union_clause
            | stream_clause
            | mr_clause
            */

parallel_clause ::= PARALLEL_KEYWORD INTEGER_LITERAL

load_clause ::= LOAD_KEYWORD STRING_LITERAL (USING_KEYWORD func_clause)? {pin=1} //as_clause?

func_clause ::= func_name (LPARENTH func_args? RPARENTH)? {pin=1}
func_name ::= id (DOT id)*
func_args ::= STRING_LITERAL (COMMA STRING_LITERAL)*

//statement ::= (assignment_statement | comment | import_statement)

comment ::= (C_STYLE_COMMENT |
             DOC_COMMENT |
             COMMENT_TAIL |
             END_OF_LINE_COMMENT
             )



//assignment_statement ::= id EQUAL thing SEMICOLON {pin=2 recoverUntil="recover_"}

thing ::= (constant | id | load | other)



constant ::= (number | string | boolean_constant | tuple_constant | bag_constant | map_constant)
tuple_constant ::= LPARENTH number (COMMA number)* RPARENTH
bag_constant ::= LBRACE tuple_constant (COMMA tuple_constant)* RBRACE
map_constant ::= LBRACK map_entry (COMMA map_entry)* RBRACK
map_entry ::= string POUND constant

number ::= (INTEGER_LITERAL | LONG_LITERAL | FLOAT_LITERAL | DOUBLE_LITERAL)
string ::= STRING_LITERAL
boolean_constant ::= (BOOLEAN_TRUE | BOOLEAN_FALSE)

storeFunc ::= IDENTIFIER LPARENTH RPARENTH

other ::= ( EXEC_LITERAL | NULL_KEYWORD | AS_KEYWORD | ASC_KEYWORD | BAG_KEYWORD | BY_KEYWORD | CACHE_KEYWORD | CHARARRAY_KEYWORD | COGROUP_KEYWORD | CROSS_KEYWORD | DEFINE_KEYWORD | DESC_KEYWORD | DISTINCT_KEYWORD | DOUBLE_KEYWORD | FILTER_KEYWORD | FLATTEN_KEYWORD | FLOAT_KEYWORD | FOREACH_KEYWORD | FULL_KEYWORD | GENERATE_KEYWORD | GROUP_KEYWORD | IF_KEYWORD | IN_KEYWORD | INNER_KEYWORD | INPUT_KEYWORD | INT_KEYWORD | INTO_KEYWORD | IS_KEYWORD | JOIN_KEYWORD | LEFT_KEYWORD | LIMIT_KEYWORD | LONG_KEYWORD | MAP_KEYWORD | MAPREDUCE_KEYWORD | ONSCHEMA_KEYWORD | ORDER_KEYWORD | OUTER_KEYWORD | OUTPUT_KEYWORD | PARALLEL_KEYWORD | PARTITION_KEYWORD | RETURNS_KEYWORD | RIGHT_KEYWORD | SAMPLE_KEYWORD | SET_KEYWORD | SHIP_KEYWORD | SPLIT_KEYWORD | STDERROR_KEYWORD | STDIN_KEYWORD | STDOUT_KEYWORD | STORE_KEYWORD | STREAM_KEYWORD | THROUGH_KEYWORD | TUPLE_KEYWORD | UNION_KEYWORD | VOID_KEYWORD | AND_KEYWORD | NOT_KEYWORD | OR_KEYWORD | STR_OP_EQ | STR_OP_GT | STR_OP_LT | STR_OP_GTE | STR_OP_LTE | STR_OP_NE | STR_OP_MATCHES | LPARENTH | RPARENTH | LBRACE | RBRACE | LBRACK | RBRACK | COMMA | DOT | EQUAL | GT | LT | QMARK | COLON | EQEQ | LTEQ | GTEQ | NOTEQ | PLUS | MINUS | STAR | DIV | POUND | PERCENT | DOUBLE_PERIOD | DOLLAR | DCOLON )*
